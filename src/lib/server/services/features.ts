/* eslint-disable @typescript-eslint/no-explicit-any */
import { z, type ZodType, type ZodRawShape } from 'zod';
import { attempt, attemptAsync } from 'ts-utils/check';
import type { Account } from '../structs/account';
import fs from 'fs';
import path from 'path';
import terminal from '../utils/terminal';

/**
 * Type for features without scopes
 */
interface FeatureWithoutScopes {
	name: string;
	description: string;
	scopes?: never;
	check?: never;
}

/**
 * Type for features with scopes
 */
interface FeatureWithScopes<T extends ZodRawShape> {
	name: string;
	description: string;
	scopes: T;
	check?: (account: Account.AccountData, scopes: z.infer<z.ZodObject<T>>) => Promise<boolean>;
}

type FeatureConfig<T extends ZodRawShape = ZodRawShape> =
	| FeatureWithoutScopes
	| FeatureWithScopes<T>;

interface RegisteredFeature {
	name: string;
	description: string;
	scopes?: ZodRawShape;
	check?: (account: Account.AccountData, scopes: any) => Promise<boolean>;
}

const features = new Map<string, RegisteredFeature>();
const FEATURES_TYPE_FILE = path.join(process.cwd(), 'src', 'lib', 'types', 'features.ts');

/**
 * Convert Zod schema to TypeScript type string
 */
function zodToTypeString(schema: ZodType, depth = 0): string {
	const indent = '  '.repeat(depth);

	if (schema instanceof z.ZodString) {
		return 'string';
	}
	if (schema instanceof z.ZodNumber) {
		return 'number';
	}
	if (schema instanceof z.ZodBoolean) {
		return 'boolean';
	}
	if (schema instanceof z.ZodDate) {
		return 'Date';
	}
	if (schema instanceof z.ZodBigInt) {
		return 'bigint';
	}
	if (schema instanceof z.ZodEnum) {
		const values = schema._def.values as string[];
		return values.map((v) => `'${v}'`).join(' | ');
	}
	if (schema instanceof z.ZodLiteral) {
		const value = schema._def.value;
		return typeof value === 'string' ? `'${value}'` : String(value);
	}
	if (schema instanceof z.ZodArray) {
		const elementType = zodToTypeString(schema._def.type, depth);
		return `Array<${elementType}>`;
	}
	if (schema instanceof z.ZodUnion) {
		const options = schema._def.options as ZodType[];
		return options.map((opt) => zodToTypeString(opt, depth)).join(' | ');
	}
	if (schema instanceof z.ZodOptional) {
		const innerType = zodToTypeString(schema._def.innerType, depth);
		return `${innerType} | undefined`;
	}
	if (schema instanceof z.ZodObject) {
		const shape = schema._def.shape() as ZodRawShape;
		const props = Object.entries(shape).map(([key, value]) => {
			const isOptional = value instanceof z.ZodOptional;
			const typeStr = zodToTypeString(value as ZodType, depth + 1);
			return `${indent}  ${key}${isOptional ? '?' : ''}: ${typeStr};`;
		});
		if (props.length === 0) {
			return '{}';
		}
		return `{\n${props.join('\n')}\n${indent}}`;
	}

	// Fallback for unsupported types
	return 'any';
}

/**
 * Generate TypeScript types file from registered features
 */
async function generateTypes() {
	return attemptAsync(async () => {
		const featureNames: string[] = [];
		const featureScopes: string[] = [];
		const featureMetadata: string[] = [];

		for (const [name, feature] of features.entries()) {
			featureNames.push(`  | '${name}'`);

			if (feature.scopes) {
				const scopeObj = z.object(feature.scopes);
				const typeStr = zodToTypeString(scopeObj);
				featureScopes.push(`  '${name}': ${typeStr};`);
			} else {
				featureScopes.push(`  '${name}': never;`);
			}

			featureMetadata.push(`  '${name}': '${feature.description.replace(/'/g, "\\'")}'`);
		}

		const content = `// Auto-generated by FeatureRegistry - DO NOT EDIT
// This file will be regenerated when features are registered

/**
 * All registered feature names
 */
export type FeatureName = ${featureNames.length > 0 ? '\n' + featureNames.join('\n') : 'never'};

/**
 * Feature scope type map
 * Each feature maps to its required scope object
 */
export interface FeatureScopes {
${featureScopes.length > 0 ? featureScopes.join('\n') : '  // No features registered yet'}
}

/**
 * Feature metadata
 */
export const FEATURE_METADATA = {
${featureMetadata.length > 0 ? featureMetadata.join(',\n') : '  // No features registered yet'}
} as const;
`;

		await fs.promises.writeFile(FEATURES_TYPE_FILE, content, 'utf-8');
		terminal.log(`Generated feature types: ${features.size} features`);
	});
}

let typeGenerationTimeout: NodeJS.Timeout | undefined;

/**
 * Schedule type generation (debounced)
 */
function scheduleTypeGeneration() {
	if (typeGenerationTimeout) {
		clearTimeout(typeGenerationTimeout);
	}
	typeGenerationTimeout = setTimeout(() => {
		generateTypes().then((result) => {
			if (result.isErr()) {
				terminal.error('Failed to generate feature types:', result.error);
			}
		});
	}, 100);
}

export namespace Features {
	/**
	 * Register a feature
	 */
	export function register<T extends ZodRawShape>(config: FeatureConfig<T>): void {
		if (features.has(config.name)) {
			terminal.warn(`Feature '${config.name}' is already registered. Overwriting...`);
		}

		features.set(config.name, {
			name: config.name,
			description: config.description,
			scopes: config.scopes,
			check: config.check
		});

		scheduleTypeGeneration();
	}

	/**
	 * Check if an account has permission for a feature
	 */
	export async function can<Name extends string>(
		account: Account.AccountData,
		featureName: Name,
		...args: Name extends keyof import('$lib/types/features').FeatureScopes
			? import('$lib/types/features').FeatureScopes[Name] extends never
				? []
				: [import('$lib/types/features').FeatureScopes[Name]]
			: []
	): Promise<boolean> {
		return attemptAsync(async () => {
			const feature = features.get(featureName);
			if (!feature) {
				terminal.warn(`Feature '${featureName}' not found`);
				return false;
			}

			// If the feature has no scopes and no check function, just return true
			if (!feature.scopes && !feature.check) {
				return true;
			}

			// If there's a check function, call it
			if (feature.check) {
				const scopes = args[0];
				if (feature.scopes && !scopes) {
					terminal.error(`Feature '${featureName}' requires scopes but none were provided`);
					return false;
				}

				// Validate scopes if provided
				if (feature.scopes && scopes) {
					const schema = z.object(feature.scopes);
					const parsed = schema.safeParse(scopes);
					if (!parsed.success) {
						terminal.error(`Invalid scopes for feature '${featureName}':`, parsed.error);
						return false;
					}
					return feature.check(account, parsed.data);
				}

				return feature.check(account, scopes || {});
			}

			// If there are scopes but no check function, just validate the scopes
			if (feature.scopes) {
				const scopes = args[0];
				if (!scopes) {
					terminal.error(`Feature '${featureName}' requires scopes but none were provided`);
					return false;
				}

				const schema = z.object(feature.scopes);
				const parsed = schema.safeParse(scopes);
				if (!parsed.success) {
					terminal.error(`Invalid scopes for feature '${featureName}':`, parsed.error);
					return false;
				}
				return true;
			}

			return true;
		}).then((result) => result.unwrapOr(false));
	}

	/**
	 * Get all registered features
	 */
	export function getAll(): ReadonlyMap<string, RegisteredFeature> {
		return features;
	}

	/**
	 * Get a specific feature by name
	 */
	export function get(name: string): RegisteredFeature | undefined {
		return features.get(name);
	}
}
