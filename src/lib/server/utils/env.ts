/**
 * @fileoverview Environment and configuration helpers with .env example generation.
 *
 * Loads config.json, provides typed access to environment variables, and keeps
 * .env.example in sync with requested keys during development.
 *
 * @example
 * import { get, num, env, config } from '$lib/server/utils/env';
 * const apiKey = get('API_KEY', { required: true });
 * const port = num('PORT', false) ?? config.network.port;
 * console.log(env);
 */
import { config as dotenv } from 'dotenv';
import fs from 'fs';
import path from 'path';
import { attemptAsync } from 'ts-utils/check';
import z from 'zod';
import configSchema from './config';
import { openJSONSync } from './files';
dotenv();

const keys = new Map<
	string,
	{
		required: boolean;
		default?: unknown;
		type?: string;
	}
>();

const cache = new Map<string, unknown>();

/**
 * Error thrown for invalid or missing environment configuration.
 */
export class EnvironmentError extends Error {
	constructor(message: string) {
		super(message);
		this.name = 'EnvironmentError';
	}
}

/**
 * Parsed and validated application configuration.
 */
export const config = (() => {
	if (!fs.existsSync(path.join(process.cwd(), 'config.json'))) {
		throw new EnvironmentError('config.json does not exist');
	}
	// const json = fs.readFileSync(path.join(process.cwd(), 'config.json'), 'utf-8');
	// return configSchema.parse(JSON.parse(json));
	return openJSONSync(path.join(process.cwd(), 'config.json'), configSchema).unwrap();
})();

/**
 * Options for `get()` environment accessor.
 *
 * @property {boolean} [required] - Whether the env var must be present.
 * @property {T} [default] - Default value when missing.
 * @property {T} [devDefault] - Default value in development when missing.
 * @property {string[]} [values] - Allowed raw string values.
 * @property {(val: string) => T} [parser] - Parser for raw value.
 * @property {string} [type] - Human-readable type for .env.example.
 */
type EnvConfig<T> = {
	required?: boolean;
	default?: T;
	devDefault?: T;
	values?: string[];
	parser?: (val: string) => T;
	type?: string;
};

let timeout: ReturnType<typeof setTimeout>;

const filepath = path.join(process.cwd(), '.env.example');
let current = '';
try {
	current = fs.readFileSync(filepath, 'utf-8');
} catch {
	console.log('.env.example does not exist, will create it automatically');
}

/**
 * Current environment name.
 */
export const env = config.environment;

/**
 * Schedules a .env.example update based on requested keys.
 */
function generateExample() {
	if (timeout) clearTimeout(timeout);
	timeout = setTimeout(async () => {
		const currentLines = current.split('\n').map((l) => l.trim());

		if (currentLines.length === 1 && currentLines[0] === '') {
			currentLines.push('# This file was auto-generated by src/lib/server/utils/env.ts');
			currentLines.push('# Feel free to comment and to replace default example values');
			currentLines.push('');
		}

		for (const [key, { required, default: def, type }] of keys) {
			if (currentLines.find((l) => l.startsWith(key + '='))) continue;
			console.log('Adding to env example:', key, type);

			let comment = `${required ? '# Required' : ''}`;
			if (type) {
				if (comment.length) comment += ` (${type})`;
				else comment += `# (${type})`;
			}

			currentLines.push(`${key}="${def ?? `some_${key.toLowerCase()}`}" ${comment}`);
		}
		fs.writeFileSync(filepath, currentLines.join('\n'));

		keys.clear();
	}, 1000);
}

// Overloads for get()
/**
 * Gets an environment variable with optional parsing/validation.
 *
 * @param {string} key - Environment key (case-insensitive).
 * @param {EnvConfig<T>} [config] - Accessor config.
 */
export function get<T = string>(key: string, config: EnvConfig<T> & { required: true }): T;
export function get<T = string>(key: string, config?: EnvConfig<T>): T | undefined;
export function get<T = string>(key: string, config?: EnvConfig<T>): T | undefined {
	if (cache.has(key)) return cache.get(key) as T;
	key = key.toUpperCase();
	const gen = (data: T) => {
		cache.set(key, data);
		if (process.env.ENVIRONMENT === 'prod') return; // Don't change git-tracked files in production
		if (!keys.has(key)) {
			keys.set(key, {
				required: config?.required ?? false,
				default: config?.default,
				type: config?.type
			});
			generateExample();
		}
	};
	const raw = process.env[key];

	if (config?.required && (config.default !== undefined || config.devDefault !== undefined)) {
		throw new EnvironmentError(
			`Env var "${key}" cannot be required and have a default or devDefault`
		);
	}

	if (config?.required && !raw) {
		throw new EnvironmentError(`Missing required env var "${key}"`);
	}

	const parse = (val: string) => (config?.parser ? config.parser(val) : (val as unknown as T));
	if (raw) {
		if (config?.values && !config.values.includes(raw)) {
			throw new EnvironmentError(
				`Invalid raw value for env var "${key}". Must be one of: ${config.values.join(', ')}`
			);
		}
		const actual = parse(raw);
		if (
			(config?.default !== undefined && typeof config.default !== typeof actual) ||
			(config?.devDefault !== undefined && typeof config.devDefault !== typeof actual)
		) {
			throw new EnvironmentError(
				`Env var "${key}" has a different type than the provided default/devDefault`
			);
		}
		gen(actual);
		return actual;
	}

	if (process.env.NODE_ENV === 'development' && config?.devDefault !== undefined) {
		gen(config.devDefault);
		return config.devDefault;
	}

	gen(config?.default as T);
	return config?.default;
}

// ===== Helper functions with correct typing =====

// Number helpers
/**
 * Reads a numeric env var.
 *
 * @param {string} key - Environment key.
 * @param {boolean} required - Whether the key is required.
 */
export function num(key: string, required: true): number;
export function num(key: string, required: false): number | undefined;
export function num(key: string, required: boolean): number | undefined {
	const res = get<number>(key, {
		required: required ?? false,
		parser: (val) => parseInt(val),
		type: 'number'
	});
	if (res !== undefined && isNaN(res)) {
		throw new EnvironmentError(`Env var "${key}" is not a valid number`);
	}

	return res;
}

// Boolean helpers
/**
 * Reads a boolean env var.
 *
 * @param {string} key - Environment key.
 * @param {boolean} required - Whether the key is required.
 */
export function bool(key: string, required: true): boolean;
export function bool(key: string, required: false): boolean | undefined;
export function bool(key: string, required: boolean): boolean | undefined {
	return get<boolean>(key, {
		required: required ?? false,
		parser: (val) => ['true', 'y', '1'].includes(val.toLowerCase()),
		type: 'y/n, true/false, 1/0',
		values: ['y', 'n', 'Y', 'N', 'true', 'false', 'TRUE', 'FALSE', 'True', 'False', '1', '0']
	});
}

// String helpers
/**
 * Reads a string env var.
 *
 * @param {string} key - Environment key.
 * @param {boolean} required - Whether the key is required.
 */
export function str(key: string, required: true): string;
export function str(key: string, required: false): string | undefined;
export function str(key: string, required: boolean): string | undefined {
	return get<string>(key, { required: required ?? false });
}

/**
 * Builds a public domain string from config.
 *
 * @param {{ port: boolean; protocol: boolean }} domainConfig - Formatting options.
 */
export function domain(domainConfig: { port: boolean; protocol: boolean }) {
	const host = config.network.host;
	const port = config.network.port;
	const protocol = config.network.protocol + '://';

	return `${domainConfig.protocol ? protocol : ''}${host}${domainConfig.port ? `:${port}` : ''}`;
}

/**
 * Fetches the public IPv4 address for the running instance.
 */
export const getPublicIp = () => {
	return attemptAsync(async () => {
		const res = await fetch('https://api.ipify.org?format=json');
		if (!res.ok) throw new Error('Failed to fetch public IP');
		return z
			.object({
				ip: z.string().ip({
					version: 'v4'
				})
			})
			.parse(await res.json()).ip;
	});
};
