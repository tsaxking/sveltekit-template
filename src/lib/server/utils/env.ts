import { config } from 'dotenv';
import fs from 'fs';
import path from 'path';
import { attemptAsync } from 'ts-utils/check';
config();

const keys = new Map<
	string,
	{
		required: boolean;
		default?: unknown;
		type?: string;
	}
>();

const cache = new Map<string, unknown>();

export class EnvironmentError extends Error {
	constructor(message: string) {
		super(message);
		this.name = 'EnvironmentError';
	}
}

type EnvConfig<T> = {
	required?: boolean;
	default?: T;
	devDefault?: T;
	values?: string[];
	parser?: (val: string) => T;
	type?: string;
};

let timeout: ReturnType<typeof setTimeout>;

const filepath = path.join(process.cwd(), '.env.example');
let current = '';
try {
	current = fs.readFileSync(filepath, 'utf-8');
} catch {
	console.log('.env.example does not exist, will create it automatically');
}

export const env = get<'dev' | 'prod' | 'test'>('ENVIRONMENT', {
	values: ['dev', 'prod', 'test'],
	required: true
});
function generateExample() {
	if (timeout) clearTimeout(timeout);
	timeout = setTimeout(async () => {
		const currentLines = current.split('\n').map((l) => l.trim());

		if (currentLines.length === 1 && currentLines[0] === '') {
			currentLines.push('# This file was auto-generated by src/lib/server/utils/env.ts');
			currentLines.push('# Feel free to comment and to replace default example values');
			currentLines.push('');
		}

		for (const [key, { required, default: def, type }] of keys) {
			if (currentLines.find((l) => l.startsWith(key + '='))) continue;
			console.log('Adding to env example:', key, type);

			let comment = `${required ? '# Required' : ''}`;
			if (type) {
				if (comment.length) comment += ` (${type})`;
				else comment += `# (${type})`;
			}

			currentLines.push(`${key}="${def ?? `some_${key.toLowerCase()}`}" ${comment}`);
		}
		fs.writeFileSync(filepath, currentLines.join('\n'));

		keys.clear();
	}, 1000);
}

// Overloads for get()
export function get<T = string>(key: string, config: EnvConfig<T> & { required: true }): T;
export function get<T = string>(key: string, config?: EnvConfig<T>): T | undefined;
export function get<T = string>(key: string, config?: EnvConfig<T>): T | undefined {
	if (cache.has(key)) return cache.get(key) as T;
	key = key.toUpperCase();
	const gen = (data: T) => {
		cache.set(key, data);
		if (process.env.ENVIRONMENT === 'prod') return; // Don't change git-tracked files in production
		if (!keys.has(key)) {
			keys.set(key, {
				required: config?.required ?? false,
				default: config?.default,
				type: config?.type
			});
			generateExample();
		}
	};
	const raw = process.env[key];

	if (config?.required && (config.default !== undefined || config.devDefault !== undefined)) {
		throw new EnvironmentError(
			`Env var "${key}" cannot be required and have a default or devDefault`
		);
	}

	if (config?.required && !raw) {
		throw new EnvironmentError(`Missing required env var "${key}"`);
	}

	const parse = (val: string) => (config?.parser ? config.parser(val) : (val as unknown as T));
	if (raw) {
		if (config?.values && !config.values.includes(raw)) {
			throw new EnvironmentError(
				`Invalid raw value for env var "${key}". Must be one of: ${config.values.join(', ')}`
			);
		}
		const actual = parse(raw);
		if (
			(config?.default !== undefined && typeof config.default !== typeof actual) ||
			(config?.devDefault !== undefined && typeof config.devDefault !== typeof actual)
		) {
			throw new EnvironmentError(
				`Env var "${key}" has a different type than the provided default/devDefault`
			);
		}
		gen(actual);
		return actual;
	}

	if (process.env.NODE_ENV === 'development' && config?.devDefault !== undefined) {
		gen(config.devDefault);
		return config.devDefault;
	}

	gen(config?.default as T);
	return config?.default;
}

// ===== Helper functions with correct typing =====

// Number helpers
export function num(key: string, required: true): number;
export function num(key: string, required: false): number | undefined;
export function num(key: string, required: boolean): number | undefined {
	const res = get<number>(key, {
		required: required ?? false,
		parser: (val) => parseInt(val),
		type: 'number'
	});
	if (res !== undefined && isNaN(res)) {
		throw new EnvironmentError(`Env var "${key}" is not a valid number`);
	}

	return res;
}

// Boolean helpers
export function bool(key: string, required: true): boolean;
export function bool(key: string, required: false): boolean | undefined;
export function bool(key: string, required: boolean): boolean | undefined {
	return get<boolean>(key, {
		required: required ?? false,
		parser: (val) => ['true', 'y', '1'].includes(val.toLowerCase()),
		type: 'y/n, true/false, 1/0',
		values: ['y', 'n', 'Y', 'N', 'true', 'false', 'TRUE', 'FALSE', 'True', 'False', '1', '0']
	});
}

// String helpers
export function str(key: string, required: true): string;
export function str(key: string, required: false): string | undefined;
export function str(key: string, required: boolean): string | undefined {
	return get<string>(key, { required: required ?? false });
}

export function domain(config: { port: boolean; protocol: boolean }) {
	const host = str('PUBLIC_DOMAIN', true);
	const port = num('PORT', true);
	const protocol = bool('HTTPS', true) ? 'https://' : 'http://';

	return `${config.protocol ? protocol : ''}${host}${config.port ? `:${port}` : ''}`;
}

export const getPublicIp = () => {
	return attemptAsync(async () => {
		const res = await fetch('https://api.ipify.org?format=json');
		if (!res.ok) throw new Error('Failed to fetch public IP');
		return z
			.object({
				ip: z.string().ip({
					version: 'v4'
				})
			})
			.parse(await res.json()).ip;
	});
};
